/*
 * Copyright (c) 2017-2020 The qitmeer developers
 */

package meer

import (
	"errors"
	"fmt"
	"github.com/Qitmeer/qng/common/hash"
	"github.com/Qitmeer/qng/consensus/model"
	"github.com/Qitmeer/qng/core/blockchain/opreturn"
	"github.com/ethereum/go-ethereum/consensus/misc/eip1559"
	"github.com/ethereum/go-ethereum/consensus/misc/eip4844"
	"github.com/ethereum/go-ethereum/core/txpool"
	"github.com/ethereum/go-ethereum/core/txpool/legacypool"
	"github.com/ethereum/go-ethereum/core/vm"
	"github.com/ethereum/go-ethereum/miner"
	"math/big"
	"sync"
	"sync/atomic"
	"time"

	qtypes "github.com/Qitmeer/qng/core/types"
	qcommon "github.com/Qitmeer/qng/meerevm/common"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/consensus"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/state"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/ethereum/go-ethereum/params"
	"github.com/ethereum/go-ethereum/trie"
)

const (
	txChanSize        = 4096
	chainHeadChanSize = 10
)

var (
	errBlockInterruptedByNewHead  = errors.New("new head arrived while building block")
	errBlockInterruptedByRecommit = errors.New("recommit interrupt while building block")
	errBlockInterruptedByTimeout  = errors.New("timeout while building block")
)

type Backend interface {
	BlockChain() *core.BlockChain
	TxPool() *txpool.TxPool
}

type resetTemplateMsg struct {
	reply chan struct{}
}

// generateParams wraps various of settings for generating sealing task.
type generateParams struct {
	timestamp   uint64            // The timstamp for sealing task
	forceTime   bool              // Flag whether the given timestamp is immutable or not
	parentHash  common.Hash       // Parent block hash, empty means the latest chain head
	coinbase    common.Address    // The fee recipient address for including transaction
	random      common.Hash       // The randomness generated by beacon chain, empty before the merge
	withdrawals types.Withdrawals // List of withdrawals to include in block.
	beaconRoot  *common.Hash      // The beacon root (cancun field). TODO: Will be redefined in the future
	noTxs       bool              // Flag whether an empty block without any transaction is expected
}

type MeerPool struct {
	wg      sync.WaitGroup
	quit    chan struct{}
	running int32

	consensus model.Consensus

	remoteTxsM  map[string]*qtypes.Tx
	remoteQTxsM map[string]*snapshotTx
	remoteMu    sync.RWMutex

	config      *miner.Config
	chainConfig *params.ChainConfig
	engine      consensus.Engine
	eth         Backend
	ethTxPool   *legacypool.LegacyPool
	chain       *core.BlockChain

	// Subscriptions
	mux          *event.TypeMux
	txsCh        chan core.NewTxsEvent
	txsSub       event.Subscription
	chainHeadCh  chan core.ChainHeadEvent
	chainHeadSub event.Subscription

	current *environment // An environment for current running cycle.

	mu sync.RWMutex // The lock used to protect the coinbase and extra fields

	snapshotMu       sync.RWMutex // The lock used to protect the snapshots below
	snapshotBlock    *types.Block
	snapshotReceipts types.Receipts
	snapshotState    *state.StateDB
	snapshotQTxsM    map[string]*snapshotTx
	snapshotTxsM     map[string]*snapshotTx
	// Feeds
	pendingLogsFeed event.Feed

	resetTemplate chan *resetTemplateMsg

	qTxPool model.TxPool
	notify  model.Notify

	interrupt *atomic.Int32
}

func (m *MeerPool) init(consensus model.Consensus, config *miner.Config, chainConfig *params.ChainConfig, engine consensus.Engine, eth Backend, mux *event.TypeMux) error {
	log.Info(fmt.Sprintf("Meer pool init..."))

	m.consensus = consensus
	m.config = config
	m.chainConfig = chainConfig
	m.engine = engine
	m.eth = eth
	m.mux = mux
	m.chain = eth.BlockChain()
	m.txsCh = make(chan core.NewTxsEvent, txChanSize)
	m.chainHeadCh = make(chan core.ChainHeadEvent, chainHeadChanSize)
	m.quit = make(chan struct{})
	m.resetTemplate = make(chan *resetTemplateMsg)
	m.remoteTxsM = map[string]*qtypes.Tx{}
	m.remoteQTxsM = map[string]*snapshotTx{}
	m.chainHeadSub = eth.BlockChain().SubscribeChainHeadEvent(m.chainHeadCh)
	for _, sp := range eth.TxPool().Subpools() {
		ltp, ok := sp.(*legacypool.LegacyPool)
		if ok {
			m.ethTxPool = ltp
			break
		}
	}
	m.txsSub = m.eth.TxPool().SubscribeTransactions(m.txsCh, true)
	m.snapshotQTxsM = map[string]*snapshotTx{}
	m.snapshotTxsM = map[string]*snapshotTx{}
	return nil
}

func (m *MeerPool) Start() {
	if m.isRunning() {
		log.Info("Meer pool was started")
		return
	}

	atomic.StoreInt32(&m.running, 1)

	m.quit = make(chan struct{})
	m.wg.Add(1)
	go m.handler()

	m.updateTemplate(nil, time.Now().Unix())
}

func (m *MeerPool) Close() {

}

func (m *MeerPool) Stop() {
	if !m.isRunning() {
		log.Info("Meer pool was stopped")
		return
	}
	atomic.StoreInt32(&m.running, 0)

	log.Info(fmt.Sprintf("Meer pool stopping"))
	if m.current != nil {
		m.current.discard()
	}
	close(m.quit)
	m.wg.Wait()

	log.Info(fmt.Sprintf("Meer pool stopped"))
}

func (m *MeerPool) isRunning() bool {
	return atomic.LoadInt32(&m.running) == 1
}

func (m *MeerPool) handler() {
	defer m.txsSub.Unsubscribe()
	defer m.chainHeadSub.Unsubscribe()
	defer m.wg.Done()
	defer func() {
		if m.current != nil {
			m.current.discard()
		}
	}()
	for {
		select {
		case ev := <-m.txsCh:
			if m.qTxPool == nil {
				continue
			}
			if !m.qTxPool.IsSupportVMTx() {
				for _, tx := range ev.Txs {
					m.ethTxPool.RemoveTx(tx.Hash(), false)
				}
				continue
			}

			if m.current != nil {
				if gp := m.current.gasPool; gp != nil && gp.Gas() < params.TxGas {
					continue
				}

				txs := make(map[common.Address][]*txpool.LazyTransaction, len(ev.Txs))
				for _, tx := range ev.Txs {
					acc, _ := types.Sender(m.current.signer, tx)
					txs[acc] = append(txs[acc], &txpool.LazyTransaction{
						Hash:      tx.Hash(),
						Tx:        tx.WithoutBlobTxSidecar(),
						Time:      tx.Time(),
						GasFeeCap: tx.GasFeeCap(),
						GasTipCap: tx.GasTipCap(),
					})
				}
				txset := miner.NewTransactionsByPriceAndNonce(m.current.signer, txs, m.current.header.BaseFee)
				tcount := m.current.tcount
				m.commitTransactions(m.current, txset, nil)
				if tcount != m.current.tcount {
					m.updateSnapshot(m.current)

					m.AnnounceNewTransactions(ev.Txs)
				}
			}

		// System stopped
		case <-m.quit:
			return
		case <-m.txsSub.Err():
			return
		case <-m.chainHeadCh:
			if m.interrupt != nil {
				m.interrupt.Store(commitInterruptNewHead)
			}
			m.interrupt = new(atomic.Int32)
			m.updateTemplate(m.interrupt, time.Now().Unix())
		case <-m.chainHeadSub.Err():
			return
		case msg := <-m.resetTemplate:
			if m.interrupt != nil {
				m.interrupt.Store(commitInterruptResubmit)
			}
			m.interrupt = new(atomic.Int32)
			m.updateTemplate(m.interrupt, time.Now().Unix())
			msg.reply <- struct{}{}
		}
	}
}

func (m *MeerPool) updateSnapshot(env *environment) {
	m.snapshotMu.Lock()
	defer m.snapshotMu.Unlock()

	m.snapshotBlock = types.NewBlock(
		env.header,
		env.txs,
		nil,
		env.receipts,
		trie.NewStackTrie(nil),
	)

	m.snapshotReceipts = qcommon.CopyReceipts(env.receipts)
	m.snapshotState = env.state.Copy()

	m.snapshotQTxsM = map[string]*snapshotTx{}
	m.snapshotTxsM = map[string]*snapshotTx{}
	if len(m.snapshotBlock.Transactions()) > 0 {
		for _, tx := range m.snapshotBlock.Transactions() {
			var mtx *qtypes.Tx
			m.remoteMu.RLock()
			qtx, ok := m.remoteTxsM[tx.Hash().String()]
			m.remoteMu.RUnlock()
			if ok {
				mtx = qtx
			} else {
				mtx = qcommon.ToQNGTx(tx, 0, true)
			}
			if mtx == nil {
				continue
			}
			stx := &snapshotTx{tx: mtx, eHash: tx.Hash()}
			m.snapshotQTxsM[mtx.Hash().String()] = stx
			m.snapshotTxsM[tx.Hash().String()] = stx
		}
	}
	//
	m.remoteMu.RLock()
	remoteSize := len(m.remoteTxsM)
	m.remoteMu.RUnlock()
	log.Debug("update meerpool snapshot", "size", len(m.snapshotBlock.Transactions()), "remoteSize", remoteSize)
}

func (m *MeerPool) commitTransaction(env *environment, tx *types.Transaction) ([]*types.Log, error) {
	if tx.Type() == types.BlobTxType {
		return m.commitBlobTransaction(env, tx)
	}

	receipt, err := m.applyTransaction(env, tx)
	if err != nil {
		return nil, err
	}
	env.txs = append(env.txs, tx)
	env.receipts = append(env.receipts, receipt)
	return receipt.Logs, nil
}

func (m *MeerPool) commitBlobTransaction(env *environment, tx *types.Transaction) ([]*types.Log, error) {
	sc := tx.BlobTxSidecar()
	if sc == nil {
		panic("blob transaction without blobs in miner")
	}
	// Checking against blob gas limit: It's kind of ugly to perform this check here, but there
	// isn't really a better place right now. The blob gas limit is checked at block validation time
	// and not during execution. This means core.ApplyTransaction will not return an error if the
	// tx has too many blobs. So we have to explicitly check it here.
	if (env.blobs+len(sc.Blobs))*params.BlobTxBlobGasPerBlob > params.MaxBlobGasPerBlock {
		return nil, errors.New("max data blobs reached")
	}

	receipt, err := m.applyTransaction(env, tx)
	if err != nil {
		return nil, err
	}
	env.txs = append(env.txs, tx.WithoutBlobTxSidecar())
	env.receipts = append(env.receipts, receipt)
	env.sidecars = append(env.sidecars, sc)
	env.blobs += len(sc.Blobs)
	*env.header.BlobGasUsed += receipt.BlobGasUsed
	return receipt.Logs, nil
}

// applyTransaction runs the transaction. If execution fails, state and gas pool are reverted.
func (m *MeerPool) applyTransaction(env *environment, tx *types.Transaction) (*types.Receipt, error) {
	var (
		snap = env.state.Snapshot()
		gp   = env.gasPool.Gas()
	)
	receipt, err := core.ApplyTransaction(m.chainConfig, m.chain, &env.coinbase, env.gasPool, env.state, env.header, tx, &env.header.GasUsed, *m.chain.GetVMConfig())
	if err != nil {
		env.state.RevertToSnapshot(snap)
		env.gasPool.SetGas(gp)
	}
	return receipt, err
}

func (m *MeerPool) commitTransactions(env *environment, txs miner.TransactionsByPriceAndNonce, interrupt *atomic.Int32) error {
	gasLimit := env.header.GasLimit
	if env.gasPool == nil {
		env.gasPool = new(core.GasPool).AddGas(gasLimit)
	}

	var coalescedLogs []*types.Log

	for {
		// Check interruption signal and abort building if it's fired.
		if interrupt != nil {
			if signal := interrupt.Load(); signal != commitInterruptNone {
				return signalToErr(signal)
			}
		}

		if env.gasPool.Gas() < params.TxGas {
			log.Trace("Not enough gas for further transactions", "have", env.gasPool, "want", params.TxGas)
			break
		}
		ltx := txs.Peek()
		if ltx == nil {
			break
		}
		tx := ltx.Resolve()
		if tx == nil {
			log.Warn("Ignoring evicted transaction")

			txs.Pop()
			continue
		}
		from, _ := types.Sender(env.signer, tx)
		if tx.Protected() && !m.chainConfig.IsEIP155(env.header.Number) {
			log.Trace("Ignoring reply protected transaction", "hash", tx.Hash(), "eip155", m.chainConfig.EIP155Block)

			txs.Pop()
			continue
		}
		env.state.SetTxContext(tx.Hash(), env.tcount)

		logs, err := m.commitTransaction(env, tx)
		switch {
		case errors.Is(err, core.ErrNonceTooLow):
			// New head notification data race between the transaction pool and miner, shift
			log.Trace("Skipping transaction with low nonce", "sender", from, "nonce", tx.Nonce())
			txs.Shift()

		case errors.Is(err, nil):
			// Everything ok, collect the logs and shift in the next transaction from the same account
			coalescedLogs = append(coalescedLogs, logs...)
			env.tcount++
			txs.Shift()

		default:
			// Transaction is regarded as invalid, drop all consecutive transactions from
			// the same sender because of `nonce-too-high` clause.
			log.Debug("Transaction failed, account skipped", "hash", tx.Hash(), "err", err)
			txs.Pop()
		}
	}
	if len(coalescedLogs) > 0 {
		cpy := make([]*types.Log, len(coalescedLogs))
		for i, l := range coalescedLogs {
			cpy[i] = new(types.Log)
			*cpy[i] = *l
		}
		m.pendingLogsFeed.Send(cpy)
	}
	return nil
}

func (m *MeerPool) prepareEnv(genParams *generateParams) (*environment, error) {
	parent := m.chain.CurrentBlock()
	if genParams.parentHash != (common.Hash{}) {
		block := m.chain.GetBlockByHash(genParams.parentHash)
		if block == nil {
			return nil, fmt.Errorf("missing parent")
		}
		parent = block.Header()
	}
	// Sanity check the timestamp correctness, recap the timestamp
	// to parent+1 if the mutation is allowed.
	timestamp := genParams.timestamp
	if parent.Time >= timestamp {
		if genParams.forceTime {
			return nil, fmt.Errorf("invalid timestamp, parent %d given %d", parent.Time, timestamp)
		}
		timestamp = parent.Time + 1
	}
	gaslimit := core.CalcGasLimit(parent.GasLimit, m.config.GasCeil)

	num := big.NewInt(0)
	num.Set(parent.Number)
	header := &types.Header{
		ParentHash: parent.Hash(),
		Number:     num.Add(num, common.Big1),
		GasLimit:   gaslimit,
		Time:       timestamp,
		Coinbase:   m.config.Etherbase,
		Difficulty: common.Big1,
	}
	// Set the extra field.
	if len(m.config.ExtraData) != 0 {
		header.Extra = m.config.ExtraData
	}
	// Set the randomness field from the beacon chain if it's available.
	if genParams.random != (common.Hash{}) {
		header.MixDigest = genParams.random
	}
	// Set baseFee and GasLimit if we are on an EIP-1559 chain
	if m.chainConfig.IsLondon(header.Number) {
		header.BaseFee = eip1559.CalcBaseFee(m.chainConfig, parent)
		if !m.chainConfig.IsLondon(parent.Number) {
			parentGasLimit := parent.GasLimit * m.chainConfig.ElasticityMultiplier()
			header.GasLimit = core.CalcGasLimit(parentGasLimit, m.config.GasCeil)
		}
	}
	// Apply EIP-4844, EIP-4788.
	if m.chainConfig.IsCancun(header.Number, header.Time) {
		var excessBlobGas uint64
		if m.chainConfig.IsCancun(parent.Number, parent.Time) {
			excessBlobGas = eip4844.CalcExcessBlobGas(*parent.ExcessBlobGas, *parent.BlobGasUsed)
		} else {
			// For the first post-fork block, both parent.data_gas_used and parent.excess_data_gas are evaluated as 0
			excessBlobGas = eip4844.CalcExcessBlobGas(0, 0)
		}
		header.BlobGasUsed = new(uint64)
		header.ExcessBlobGas = &excessBlobGas
		header.ParentBeaconRoot = genParams.beaconRoot
	}
	if err := m.engine.Prepare(m.chain, header); err != nil {
		log.Error("Failed to prepare header for meerpool", "err", err)
		return nil, err
	}
	env, err := m.makeEnv(parent, header, genParams.coinbase)
	if err != nil {
		log.Error("Failed to create meerpool context", "err", err)
		return nil, err
	}
	if header.ParentBeaconRoot != nil {
		context := core.NewEVMBlockContext(header, m.chain, nil)
		vmenv := vm.NewEVM(context, vm.TxContext{}, env.state, m.chainConfig, vm.Config{})
		core.ProcessBeaconBlockRoot(*header.ParentBeaconRoot, vmenv, env.state)
	}
	return env, nil
}

func (m *MeerPool) makeEnv(parent *types.Header, header *types.Header, coinbase common.Address) (*environment, error) {
	state, err := m.chain.StateAt(parent.Root)
	if err != nil {
		return nil, err
	}
	state.StartPrefetcher("meerpool")

	env := &environment{
		signer:   types.MakeSigner(m.chainConfig, header.Number, header.Time),
		state:    state,
		coinbase: coinbase,
		header:   header,
	}
	env.tcount = 0
	return env, nil
}

func (m *MeerPool) updateTemplate(interrupt *atomic.Int32, timestamp int64) {
	preBlock := m.PendingBlock()
	if preBlock != nil {
		if preBlock.ParentHash() == m.chain.CurrentBlock().Hash() {
			log.Debug("meerpool block template no update required")
			return
		}
	}
	log.Debug("meerpool update block template")
	m.mu.Lock()
	defer m.mu.Unlock()

	start := time.Now()

	env, err := m.prepareEnv(&generateParams{
		timestamp: uint64(timestamp),
		coinbase:  m.config.Etherbase,
	})
	if err != nil {
		return
	}
	// Fill pending transactions from the txpool into the block.
	err = m.fillTransactions(interrupt, env)
	switch {
	case errors.Is(err, errBlockInterruptedByNewHead):
		// If the block building is interrupted by newhead event, discard it
		// totally. Committing the interrupted block introduces unnecessary
		// delay, and possibly causes miner to mine on the previous head,
		// which could result in higher uncle rate.
		env.discard()
		return
	}
	// Submit the generated block for consensus sealing.
	m.commit(env, true, start)

	// Swap out the old work with the new one, terminating any leftover
	// prefetcher processes in the mean time and starting a new one.
	if m.current != nil {
		m.current.discard()
	}
	m.current = env
}

func (m *MeerPool) fillTransactions(interrupt *atomic.Int32, env *environment) error {
	pending := m.eth.TxPool().Pending(true)

	// Split the pending transactions into locals and remotes.
	localTxs, remoteTxs := make(map[common.Address][]*txpool.LazyTransaction), pending
	for _, account := range m.eth.TxPool().Locals() {
		if txs := remoteTxs[account]; len(txs) > 0 {
			delete(remoteTxs, account)
			localTxs[account] = txs
		}
	}

	// Fill the block with all available pending transactions.
	if len(localTxs) > 0 {
		txs := miner.NewTransactionsByPriceAndNonce(env.signer, localTxs, env.header.BaseFee)
		if err := m.commitTransactions(env, txs, interrupt); err != nil {
			return err
		}
	}
	if len(remoteTxs) > 0 {
		txs := miner.NewTransactionsByPriceAndNonce(env.signer, remoteTxs, env.header.BaseFee)
		if err := m.commitTransactions(env, txs, interrupt); err != nil {
			return err
		}
	}
	return nil
}

func (m *MeerPool) commit(env *environment, update bool, start time.Time) error {
	receipts := qcommon.CopyReceipts(env.receipts)
	s := env.state.Copy()
	block, err := m.engine.FinalizeAndAssemble(m.chain, env.header, s, env.txs, []*types.Header{}, receipts, nil)
	if err != nil {
		log.Error(err.Error())
		return err
	}
	log.Debug("Update meerpool", "number", block.Number(), "txs", env.tcount,
		"gas", block.GasUsed(), "fees", qcommon.TotalFees(block, receipts), "elapsed", common.PrettyDuration(time.Since(start)))

	if update {
		m.updateSnapshot(env)
	}
	return nil
}

func (m *MeerPool) AddTx(tx *qtypes.Tx, local bool) (int64, error) {
	if local {
		log.Warn("This function is not supported for the time being: local meer tx")
		return 0, nil
	}
	if !opreturn.IsMeerEVMTx(tx.Tx) {
		return 0, fmt.Errorf("%s is not %v", tx.Hash().String(), qtypes.TxTypeCrossChainVM)
	}
	h := qcommon.ToEVMHash(&tx.Tx.TxIn[0].PreviousOut.Hash)
	if m.eth.TxPool().Has(h) {
		return 0, fmt.Errorf("already exists:%s (evm:%s)", tx.Hash().String(), h.String())
	}
	txb := qcommon.ToTxHex(tx.Tx.TxIn[0].SignScript)
	var txmb = &types.Transaction{}
	err := txmb.UnmarshalBinary(txb)
	if err != nil {
		return 0, err
	}

	errs := m.ethTxPool.AddRemotesSync(types.Transactions{txmb})
	if len(errs) > 0 && errs[0] != nil {
		return 0, errs[0]
	}
	m.remoteMu.Lock()
	m.remoteTxsM[txmb.Hash().String()] = tx
	m.remoteQTxsM[tx.Hash().String()] = &snapshotTx{tx: tx, eHash: txmb.Hash()}
	remoteSize := len(m.remoteTxsM)
	m.remoteMu.Unlock()
	log.Debug("Meer pool:add", "hash", tx.Hash(), "eHash", txmb.Hash(), "size", remoteSize)

	//
	cost := txmb.Cost()
	cost = cost.Sub(cost, txmb.Value())
	cost = cost.Div(cost, qcommon.Precision)
	return cost.Int64(), nil
}

func (m *MeerPool) GetTxs() ([]*qtypes.Tx, []*hash.Hash, error) {
	m.snapshotMu.RLock()
	defer m.snapshotMu.RUnlock()

	result := []*qtypes.Tx{}
	mtxhs := []*hash.Hash{}

	if m.snapshotBlock != nil && len(m.snapshotBlock.Transactions()) > 0 {
		for _, tx := range m.snapshotBlock.Transactions() {
			qtx, ok := m.snapshotTxsM[tx.Hash().String()]
			if !ok {
				continue
			}
			result = append(result, qtx.tx)
			mtxhs = append(mtxhs, qcommon.FromEVMHash(tx.Hash()))
		}
	}

	return result, mtxhs, nil
}

// all: contain txs in pending and queue
func (m *MeerPool) HasTx(h *hash.Hash, all bool) bool {
	m.snapshotMu.RLock()
	_, ok := m.snapshotQTxsM[h.String()]
	m.snapshotMu.RUnlock()

	if all && !ok {
		m.remoteMu.RLock()
		stx, okR := m.remoteQTxsM[h.String()]
		m.remoteMu.RUnlock()
		if okR && stx != nil {
			ok = m.eth.TxPool().Has(stx.eHash)
		}
	}
	return ok
}

func (m *MeerPool) GetSize() int64 {
	m.snapshotMu.RLock()
	defer m.snapshotMu.RUnlock()

	if m.snapshotBlock != nil {
		return int64(len(m.snapshotBlock.Transactions()))
	}
	return 0
}

func (m *MeerPool) RemoveTx(tx *qtypes.Tx) error {
	if !m.isRunning() {
		return fmt.Errorf("meer pool is not running")
	}
	if !opreturn.IsMeerEVMTx(tx.Tx) {
		return fmt.Errorf("%s is not %v", tx.Hash().String(), qtypes.TxTypeCrossChainVM)
	}

	m.remoteMu.Lock()
	h := qcommon.ToEVMHash(&tx.Tx.TxIn[0].PreviousOut.Hash)
	_, ok := m.remoteTxsM[h.String()]
	if ok {
		delete(m.remoteTxsM, h.String())
		delete(m.remoteQTxsM, tx.Hash().String())
		log.Debug(fmt.Sprintf("Meer pool:remove tx %s(%s) from remote, size:%d", tx.Hash().String(), h, len(m.remoteTxsM)))
	}
	m.remoteMu.Unlock()

	if m.eth.TxPool().Has(h) {
		m.ethTxPool.RemoveTx(h, false)
		log.Debug(fmt.Sprintf("Meer pool:remove tx %s(%s) from eth", tx.Hash(), h))
	}

	return nil
}

func (m *MeerPool) AnnounceNewTransactions(txs []*types.Transaction) error {
	if m.ethTxPool.All().LocalCount() <= 0 {
		return nil
	}
	localTxs := []*qtypes.TxDesc{}

	for _, tx := range txs {
		m.snapshotMu.RLock()
		qtx, ok := m.snapshotTxsM[tx.Hash().String()]
		m.snapshotMu.RUnlock()
		if !ok || qtx == nil {
			continue
		}
		if m.ethTxPool.All().GetLocal(tx.Hash()) == nil {
			continue
		}
		//
		cost := tx.Cost()
		cost = cost.Sub(cost, tx.Value())
		cost = cost.Div(cost, qcommon.Precision)
		fee := cost.Int64()

		td := &qtypes.TxDesc{
			Tx:       qtx.tx,
			Added:    time.Now(),
			Height:   m.qTxPool.GetMainHeight(),
			Fee:      fee,
			FeePerKB: fee * 1000 / int64(qtx.tx.Tx.SerializeSize()),
		}

		localTxs = append(localTxs, td)
		m.qTxPool.AddTransaction(td.Tx, uint64(td.Height), td.Fee)
	}
	if len(localTxs) <= 0 {
		return nil
	}
	//
	m.notify.AnnounceNewTransactions(localTxs, nil)
	go m.notify.AddRebroadcastInventory(localTxs)

	return nil
}

func (m *MeerPool) Mining() bool {
	log.Debug("Temporarily not supported: Mining")
	return false
}

func (m *MeerPool) Hashrate() uint64 {
	log.Debug("Temporarily not supported: Hashrate")
	return 0
}

func (m *MeerPool) SetExtra(extra []byte) error {
	log.Debug("Temporarily not supported: SetExtra")
	return nil
}

func (m *MeerPool) SetRecommitInterval(interval time.Duration) {
	log.Debug("Temporarily not supported: SetRecommitInterval")
}

func (m *MeerPool) Pending() (*types.Block, *state.StateDB) {
	m.snapshotMu.RLock()
	defer m.snapshotMu.RUnlock()
	if m.snapshotState == nil {
		return nil, nil
	}
	return m.snapshotBlock, m.snapshotState.Copy()
}

func (m *MeerPool) PendingBlock() *types.Block {
	m.snapshotMu.RLock()
	defer m.snapshotMu.RUnlock()
	return m.snapshotBlock
}

func (m *MeerPool) PendingBlockAndReceipts() (*types.Block, types.Receipts) {
	m.snapshotMu.RLock()
	defer m.snapshotMu.RUnlock()
	return m.snapshotBlock, m.snapshotReceipts
}

func (m *MeerPool) SetEtherbase(addr common.Address) {
	log.Debug("Temporarily not supported: SetEtherbase")
}

func (m *MeerPool) SetGasCeil(ceil uint64) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.config.GasCeil = ceil
}

func (m *MeerPool) SubscribePendingLogs(ch chan<- []*types.Log) event.Subscription {
	return m.pendingLogsFeed.Subscribe(ch)
}

func (m *MeerPool) GetSealingBlockAsync(parent common.Hash, timestamp uint64, coinbase common.Address, random common.Hash, noTxs bool) (chan *types.Block, error) {
	return nil, nil
}

func (m *MeerPool) GetSealingBlockSync(parent common.Hash, timestamp uint64, coinbase common.Address, random common.Hash, noTxs bool) (*types.Block, error) {
	return nil, nil
}

func (m *MeerPool) BuildPayload(args *miner.BuildPayloadArgs) (*miner.Payload, error) {
	return nil, nil
}

func (m *MeerPool) ResetTemplate() error {
	log.Debug("Try to reset meer pool")
	msg := &resetTemplateMsg{reply: make(chan struct{})}
	m.resetTemplate <- msg
	<-msg.reply
	return nil
}

func (m *MeerPool) SetTxPool(tp model.TxPool) {
	m.qTxPool = tp
}

func (m *MeerPool) SetNotify(notify model.Notify) {
	m.notify = notify
}

type snapshotTx struct {
	tx    *qtypes.Tx
	eHash common.Hash
}
